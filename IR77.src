dnl   Copyright (c) 2008 by Jochen Roessner <jochen@lugrot.de>
dnl   This program is free software; you can redistribute it and/or modify
dnl   it under the terms of the GNU General Public License version 2 or later
dnl   as published by the Free Software Foundation.
dnl  
dnl   This program is distributed in the hope that it will be useful,
dnl   but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
dnl   GNU General Public License for more details.
dnl  
dnl   You should have received a copy of the GNU General Public License
dnl   along with this program; if not, write to the Free Software
dnl   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
dnl  
dnl   For more information on the GPL, please go to:
dnl   http://www.gnu.org/copyleft/gpl.html
dnl

enum sensor { Kessel,Vorlauf,Wasser,WasserRuecklauf,WasserZulauf,AussenNord,Ruecklauf,Ofen };

C6_HEADER(`/* This will be in control6.h */')

CONTROL_START

dnl // dnl ist der kommentar fuer m4. Zum aktivieren der beispiele einfach das dnl entfernen.

dnl  // dieses Beispiel zeigt anhand meiner Heizungssteuerung wie man zeitverzoegert die Wasserheizung
dnl  // schaltet. Das geschieht bei einer Temperatur groesser als 55,0 Grad und nur zwischen 6 und 11 Uhr 
dnl  THREAD(warmwasser_high)
dnl      WAIT(60 * 15);
dnl      PIN_SET(Warmwasser);
dnl      THREAD_WAIT(warmwasser_high);
dnl  THREAD_END(warmwasser_high)
dnl  ON ONCE CLOCK_MIN && ( CLOCK_HOUR > 11 || CLOCK_HOUR < 6 ) && KTY_GET(Wasser) > 550 DO THREAD_START(warmwasser_high) END

dnl  // das Beispiel zeigt wie man sofort (einmal in der Minute) auf auf die Wassertemperatur reagiert und schaltet
dnl  // der Pinname "Warmwasser" stammt aus der Konfig vom named_pin
dnl  ON ONCE CLOCK_MIN && CLOCK_HOUR > 6 && CLOCK_HOUR < 19 && KTY_GET(Wasser) < 400 DO
dnl    PIN_CLEAR(Warmwasser);
dnl  END

dnl  // ein Thread der in einer Endlosschleife mit 5 Sekunden Verzoegerung laeuft 
dnl  // definiert eine globale Variable
dnl  GLOBAL(lastzulauf, uint16_t);
dnl  THREAD(zulauf)
dnl    ON ADC_GET(WasserZulauf) < (lastzulauf - 1) DO
dnl      //sendet ein ecmd an ein anderes ethersex
dnl      UESEND(2001:6f8:1209:0:0:0:0:e6, "pumpe 0 1 0\n");
dnl      WAIT(120);
dnl      UESEND(2001:6f8:1209:0:0:0:0:e6, "pumpe 0 0 0\n");
dnl      lastzulauf = ADC_GET(WasserZulauf);
dnl    END
dnl    ON ADC_GET(4) > lastzulauf DO
dnl	lastzulauf = ADC_GET(WasserZulauf);
dnl    END
dnl    WAIT(5)
dnl  THREAD_END(zulauf)

dnl  ON STARTUP DO
dnl      THREAD_START(zulauf);
dnl  END

dnl  // schaltet morgens um 6 Uhr die Heizung ein wenn es draussen weniger als 3 Grad hat
dnl  ON ONCE CLOCK_MIN == 0 && CLOCK_HOUR == 6 && KTY_GET(AussenNord) < 30 DO
dnl    PIN_CLEAR(Heizung);
dnl  END

dnl  // reagiert sofort auf eine fallende Flanke am Eingangspin
dnl  ON PIN_FALLING(Heizzirkulationspumpe) DO
dnl    UESEND(2001:6f8:1209:0:0:0:0:e6, "pumpe 1 1 0\n");
dnl  END
dnl  ON PIN_RISING(Heizzirkulationspumpe) DO
dnl    UESEND(2001:6f8:1209:0:0:0:0:e6, "pumpe 1 0 0\n");
dnl  END
dnl  // alle 10 Minuten wird geprueft ob der Pin low ist und ggf ein ecmd gesendet
dnl  ON ONCE CLOCK_MIN % 10 == 0 DO
dnl    ON PIN_LOW(Heizzirkulationspumpe) DO
dnl      UESEND(2001:6f8:1209:0:0:0:0:e6, "pumpe 1 1 0\n");
dnl    END
dnl  END

dnl // eine globale Variable fuer ecmd verwendet man so
dnl ECMD_GLOBAL(Wassersoll, 20);
dnl ECMD_GLOBAL(Raumsoll, 20);
dnl ON Wassersoll > 30 DO
dnl   Wassersoll = 30;
dnl END
dnl // die ecmd syntax ist "c6 get Wassersoll" oder "c6 set Wassersoll 255"
dnl // die werte koennen von 0 bis 255 gehen.
   uint16_t rc5 = RC5_GET();
   DDR_CONFIG_OUT(CHANNEL1);
   DDR_CONFIG_OUT(CHANNEL2);
   DDR_CONFIG_OUT(CHANNEL3);
   DDR_CONFIG_OUT(CHANNEL4);
   DDR_CONFIG_OUT(CHANNEL5);
   DDR_CONFIG_OUT(CHANNEL6);
   DDR_CONFIG_OUT(CHANNEL7);
   DDR_CONFIG_OUT(CHANNEL8);
   

   define(REWIND,  0x0532)
   define(PLAY,    0x0535)
   define(FORWARD, 0x0534)
   define(PAUSE,   0x0529)
   define(STOP,    0x0536)
   define(RECORD,  0x0537)
 
   /* Channels */
   define(POWER_ON,  0x053a)
   define(POWER_OFF, 0x050e)
   define(IR1, 0x0501)
   define(IR2, 0x0502)
   define(IR3, 0x0503)
   define(IR4, 0x0504)
   define(IR5, 0x0505)
   define(IR6, 0x0506)
   define(IR7, 0x0507)
   define(IR8, 0x0508)
   
   static uint16_t last_press = 0;

   define(`PROCESS_CHANNEL', `dnl
  ON rc5 == POWER_ON  && last_press == IR$1 DO PIN_SET(`CHANNEL$1'); END
  ON rc5 == POWER_OFF && last_press == IR$1 DO PIN_CLEAR(`CHANNEL$1'); END')
  
   PROCESS_CHANNEL(1);
   PROCESS_CHANNEL(2);
   PROCESS_CHANNEL(3);
   PROCESS_CHANNEL(4);
   PROCESS_CHANNEL(5);
   PROCESS_CHANNEL(6);
   PROCESS_CHANNEL(7);
   PROCESS_CHANNEL(8);


   ON rc5 != 0 DO last_press = rc5; END

CONTROL_END

